### **진기의 최고급 붕어빵**
---

```
def start():
    sold_bread = 0
    for person in customers:
        # 공식, 특정 시간에 만들 수 있는 빵의 개수
        made_bread = (person // m) * k

        # 빵을 1개 팔았다.
        sold_bread += 1

        # 재고 계산
        remain = made_bread - sold_bread

        # 재고가 0보다 작으면 실패
        if remain < 0:
            return 'Impossible'
    # 실패가 없었으면 성공
    return 'Possible'

T = int(input())
for tc in range(T):
    # 손님수, m 초에 k개의 빵을 만든다. 손님들이 도착하는 시간 customers
    n, m, k = map(int, input().split())
    customers = list(map(int, input().split()))
    # 손님이 오는 시간 정렬 (오름차순)
    customers.sort()
    result = start()
    print(f'#{tc+1} {result}')

```

### **Magnetic**
---

```
# 열 검사 함수

def get_sero_cnt(col):
    cnt = 0
    # red 자성체를 체크
    is_red = True

    for row in range(N):
        # 1. red 발견
        if arr[row][col] == 1:
            is_red = True
        # 2. 이전에 red 자성체를 발견했고, 현재 blue 자성체 발견 cnt += 1
        elif is_red and arr[row][col] == 2:
            cnt += 1
            is_red = False  # 갱신
    return cnt
T = 10
for tc in range(T):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(100)]
    total_count = 0
    # 열 순회하면서 total_count 누적
    for col in range(N):
        total_count += get_sero_cnt(col)
    print(f'#{tc+1} {total_count}')
```

### **자기방으로 돌아가기**
---

내 기존 풀이!

```
T = int(input())
for tc in range(T):
    N = int(input())
    room = [list(map(int, input().split())) for _ in range(N)]
    corridor = [0] * 400

    for i in range(N):
        if room[i][0] < room[i][1]:
            for j in range((room[i][0]-1)//2, (room[i][1]-1)//2+1):
                corridor[j] += 1

        else:
            for j in range((room[i][1]-1)//2, (room[i][0]-1)//2+1):
                corridor[j] += 1

    print(f'#{tc+1} {max(corridor)}')
```

오류가 발생했던 부분!

짝수방 홀수방이 분리되어 있어서 복도에서 시작점 혹은 끝점이 만나는 경우가 있는데, 이때 그냥 for j in range(room[i][0], room[i][1]) 이렇게 적으면 오류가 발생했었다! 오류를 해결하기 위해 1 & 2, 3 & 4, 5 & 6번방이 각각 같은 복도 0, 1, 2 를 공유한다는 것을 확인하고 (room[i][1]-1)//2 해서 문제를 접근했다!

for j in range((room[i][1]-1)//2, (room[i][0]-1)//2+1): 범위를 지정해줄 때 마지막 (room[i][0]-1)//2도 range안에 나타나야 하므로 +1 을 해준다.

특징 1. 목적지가 출발지보다 크게!

특징 2. if 짝수: s -= 1, e -= 1 (아랫방이면 1을 빼서 위층으로 올려주기)

### **오목**
---

**유의사항**

![](https://velog.velcdn.com/images/lurelight/post/0b040e0f-6a36-4bf8-b516-f975b9042ac5/image.png)

break가 덜 순회하기 때문에 시간복잡도가 더 좋아 더 좋은 성능을 낸다.

```
def f(N):
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 'o':
                # 오른쪽, 오른쪽아래, 아래, 왼쪽 아래 4방향만 검사. 반대방향은 맞은편과 중복됨.
                for di, dj in [[0, 1], [1, 1], [1, 0], [1, -1]]:
                    cnt = 1
                    ni, nj = i + di, j + dj
                    while 0 <= ni < N and 0 <= nj < N and arr[ni][nj] == 'o':
                        cnt += 1
                        if cnt == 5:
                            return 'YES'
                        ni, nj = ni + di, nj + dj
    return 'NO'


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    arr = [input() for _ in range(N)]

    print(f'#{tc} {f(N)}')
```

### **재미있는 오셀로 게임**
---

```
di = [0, 1, 0, -1, 1, 1, -1, -1]
dj = [1, 0, -1, 0, 1, -1, -1, 1]
# 반대 돌의 색 1 -> 2, 2 -> 1
op = [0, 2, 1]  # 반대편 돌의 색 op[bw]
def f(i, j, wb, N):     # i, j 돌을 놓을 행, 열. wb 돌의 색, N 게임판의 크기
    board[i][j] = wb    # board[i][j]에 wb 돌 놓기
    # 8 개의 방향에 대해서, 뒤집을 수 있는지 확인
    for k in range(8):
        flip = []   # 같은색 돌을 만나면 뒤집을 위치 저장
        ni, nj = i + di[k], j + dj[k]
        while 0 <= ni < N and 0 <= nj < N and board[ni][nj] == op[wb]:  # ni, nj 에 반대색 돌이 있으면 이동
            flip.append((ni, nj))   # 뒤집을 후보
            ni, nj = ni + di[k], nj + dj[k]     # 이동
        if 0 <= ni < N and 0 <= nj < N and board[ni][nj] == wb:     # 같은 색을 만나서 중단된 경우
            for p, q in flip:   # 중간에 있는 돌 뒤집기
                board[p][q] = wb

B = 1 # 흑돌
W = 2 # 백돌
# 1부터 입력하는 것 기준
T =int(input())
for tc in range(T):
    N, M = map(int, input().split())    # N 보드 크기, M 돌을 놓는 횟수
    play = [list(map(int, input().split())) for _ in range(M)]  # 열, 행, 돌 : 돌을 놓는 정보 저장

    board = [[0] * N for _ in range(N)]    # 인덱스를 0부터 시작 (문제 입력은 1부터)

    board[N//2-1][N//2-1] = W       # 4개의 돌 놓기

    board[N//2-1][N//2] = B

    board[N//2][N//2-1] = B

    board[N//2][N//2] = W

    for j, i, wb in play:
        f(i-1, j-1, wb, N)      # 돌을 놓는 함수, 입력은 인덱스 1부터, 처리는 인덱스 0부터!

    cnt_b = cnt_w = 0
    for i in range(N):
        for j in range(N):
            if board[i][j] == W:
                cnt_w += 1
            else:
                board[i][j] == B
                cnt_b += 1

    print(f'#{tc+1} {cnt_b} {cnt_w}')
```